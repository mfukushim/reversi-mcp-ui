// reversi.ts
// Reversi Engine (A1=左上, "B"/"W", 64文字ボード). PASS 対応。
//  by ChatGPT 5

type Color = "B" | "W";
type Cell = "." | "B" | "W";

export interface ExportState {
  board: string;          // 64文字 (A1..H1, A2..H2, ... A8..H8)
  to: Color;              // 次手番
  legal: string[];        // 次手番の合法手 (座標)
  black: number;          // 黒の石数
  white: number;          // 白の石数
}

// export interface PlayResult extends ExportState {
//   ok: boolean;            // 着手が適法・反映済みなら true
//   played?: string;        // 実際に打った座標（PASS なら "PASS"）
//   flipped?: string[];     // 返った座標一覧
//   message?: string;       // パスや終局のメッセージ
//   error?: string;         // 反則時の説明
// }
//
// const DIRS: Array<[dr: number, dc: number]> = [
//   [-1, 0], [1, 0], [0, -1], [0, 1],
//   [-1, -1], [-1, 1], [1, -1], [1, 1],
// ];
//
// function inRange(r: number, c: number) { return r >= 0 && r < 8 && c >= 0 && c < 8; }
// function opp(color: Color): Color { return color === "B" ? "W" : "B"; }
//
// function algebraicToRC(s: string): { r: number; c: number } {
//   if (!/^[A-H][1-8]$/.test(s)) throw new Error(`Coordinates are in an invalid format: ${s}`); //  座標の形式が不正です
//   const c = s.charCodeAt(0) - 65;         // 'A'→0
//   const r = s.charCodeAt(1) - 49;         // '1'→0
//   return { r, c };
// }
// function rcToAlgebraic(r: number, c: number): string {
//   return String.fromCharCode(65 + c) + String.fromCharCode(49 + r);
// }
//
// function counts(board: Cell[][]) {
//   let b = 0, w = 0;
//   for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
//     if (board[r][c] === "B") b++;
//     else if (board[r][c] === "W") w++;
//   }
//   return { black: b, white: w };
// }
//
// function boardTo64(board: Cell[][]): string {
//   let s = "";
//   for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) s += board[r][c];
//   return s;
// }

//  reversiEngine generated by ChatGPT 5

export class ReversiEngine {
  private b: Cell[] = Array(64).fill(".");
  private to: Color = "B";

  /** 標準初期配置で初期化 */
  init(): ExportState {
    console.log("Initializing ReversiEngine");
    this.b = Array(64).fill(".");
    // (r,c) を index に：idx = r*8 + c
    this.b[3 * 8 + 3] = "W";
    this.b[3 * 8 + 4] = "B";
    this.b[4 * 8 + 3] = "B";
    this.b[4 * 8 + 4] = "W";
    this.to = "B";
    return this.export();
  }

  /** 盤面・手番を外部から取り込む（検証 & 再計算） */
  import(state: Pick<ExportState, "board" | "to">): ExportState {
    // 検証：長さ・文字種
    if (state.board.length !== 64) {
      throw new Error("board は 64 文字である必要があります");
    }
    const arr: Cell[] = [];
    for (let i = 0; i < 64; i++) {
      const ch = state.board[i] as Cell;
      if (ch !== "." && ch !== "B" && ch !== "W") {
        throw new Error(`board の ${i} 文字目が不正です: '${state.board[i]}'`);
      }
      arr.push(ch);
    }
    if (state.to !== "B" && state.to !== "W") {
      throw new Error("to は 'B' または 'W' である必要があります");
    }
    this.b = arr;
    this.to = state.to;
    // 合法手/カウントは自前で再計算
    return this.export();
  }

  /** 現在状態を書き出し（legal/black/white 再計算） */
  export(): ExportState {
    const legal = this.legalMoves(this.to);
    const { black, white } = this.counts();
    return { board: this.b.join(""), to: this.to, legal, black, white };
  }

/** 黒の着手 */
  public playBlack(move: string) {
    return this.play("B", move);
  }

/** 白の着手 */
  public playWhite(move: string) {
    return this.play("W", move);
  }

  /** 現在手番で座標を打つ（合法でなければ false） */
  play(to:Color,coord: string): { ok: boolean; error?: string; reset?:boolean; pass?:boolean; placedIdx?: number } {
    if (coord === "NEW"){
      this.init(); // 盤面初期化 手番は黒
      return { ok:true, reset:true };
    }
    if (to !== this.to) {
      return { ok: false, error: "手番不正" }
    }
    if (coord === "PASS") {
      const leg = this.legalMoves(this.to);
      if (leg.length) return { ok: false, error: "まだ合法手があります" };
      this.to = this.opp(this.to);
      return { ok: true, pass:true };
    }
    if (!/^[A-H][1-8]$/.test(coord)) return { ok: false, error: "座標が不正です" };
    const i = this.idx(coord);
    if (this.b[i] !== ".") return { ok: false, error: "既に石があります" };

    const flips = this.flips(i, this.to);
    if (!flips.length) {
      console.log('board:',this.b,to,coord)
      return {ok: false, error: "取れません"};
    }

    // 反映
    this.b[i] = this.to;
    for (const j of flips) this.b[j] = this.to;

    // 相手に手番
    this.to = this.opp(this.to);
    // 相手が打てないなら自動パスで手番を戻す（終局判定は export() 側の legal で分かる）
    if (this.legalMoves(this.to).length === 0) {
      this.to = this.opp(this.to);
    }
    return { ok: true, placedIdx: i };
  }

  // ---- 内部ユーティリティ ----
  private opp(c: Color): Color { return c === "B" ? "W" : "B"; }
  private idx(coord: string): number {
    const c = coord.charCodeAt(0) - 65;
    const r = coord.charCodeAt(1) - 49;
    return r * 8 + c;
  }
  private rc(i: number): [number, number] { return [Math.floor(i / 8), i % 8]; }
  private coord(i: number): string {
    return String.fromCharCode(65 + (i % 8)) + String.fromCharCode(49 + Math.floor(i / 8));
  }
  private counts() {
    let black = 0, white = 0;
    for (const x of this.b) { if (x === "B") black++; else if (x === "W") white++; }
    return { black, white };
  }
  private legalMoves(color: Color): string[] {
    const res: string[] = [];
    for (let i = 0; i < 64; i++) {
      if (this.b[i] !== ".") continue;
      if (this.flips(i, color).length > 0) res.push(this.coord(i));
    }
    return res;
  }
  private flips(i: number, color: Color): number[] {
    if (this.b[i] !== ".") return [];
    const [r, c] = this.rc(i);
    const opp = this.opp(color);
    const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
    const res: number[] = [];
    for (const [dr, dc] of dirs) {
      let rr = r + dr, cc = c + dc;
      const tmp: number[] = [];
      while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8 && this.b[rr * 8 + cc] === opp) {
        tmp.push(rr * 8 + cc); rr += dr; cc += dc;
      }
      if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8 && this.b[rr * 8 + cc] === color && tmp.length) {
        res.push(...tmp);
      }
    }
    return res;
  }
}

