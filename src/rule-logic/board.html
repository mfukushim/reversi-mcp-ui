<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- reversi drawer and reversi engine generated by ChatGPT 5 -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reversi - Single HTML (Responsive + Guides)</title>
  <style>
    :root{
      --gap: clamp(2px, 1.2vw, 10px);
    }
    *{ box-sizing:border-box; }
    body{ min-height: 100vh; margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; background:#fafafa; color:#222; }
    .wrap{ max-width: 720px; margin: 0 auto; padding: 12px; }
    .header{ display:flex; gap:12px; align-items:center; justify-content:space-between; margin: 10px 0; flex-wrap:wrap;}
    .badge{ background:#e3f2fd; border-radius:999px; padding:6px 10px; font-weight:600; }
    .counts{ display:flex; gap:8px; align-items:center; }
    .counts .disc{ width:16px; height:16px; border-radius:50%; box-shadow: inset 0 2px 4px rgba(0,0,0,.35); }
    .counts .disc.b{ background:#111; }
    .counts .disc.w{ background:#f7f7f7; border:1px solid rgba(0,0,0,.15); }

    .board{
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;           /* 正方形を維持 */
      background: #174d1b;
      padding: calc(var(--gap) * 2 + 18px); /* ラベルの余白を確保 */
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(0,0,0,.08), inset 0 0 0 2px rgba(255,255,255,.08);
    }
    .grid{
      position: relative;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: var(--gap);
      width: 100%; height: 100%;
    }
    .cell{
      position: relative;
      background: linear-gradient(135deg, #2f7d32, #266628);
      border-radius: 8px;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.15);
      cursor: pointer;
      outline: none;
    }
    .cell:hover{ filter: brightness(1.06); }
    .cell:focus-visible{ box-shadow: 0 0 0 3px #ffc107, inset 0 0 0 2px rgba(0,0,0,.2); }

    .disc{
      position:absolute; inset: 12%; border-radius: 50%;
      box-shadow: inset 0 6px 10px rgba(0,0,0,.35), 0 3px 8px rgba(0,0,0,.2);
      opacity:1; transform: scale(1);
    }
    .disc.B{ background:#111; }
    .disc.W{ background:#f7f7f7; border:1px solid rgba(0,0,0,.1); }
    .hint{ position:absolute; inset: 38%; border-radius: 50%; background: rgba(0,0,0,.18); box-shadow: 0 1px 2px rgba(0,0,0,.15); }

    /* 置石アニメ */
    @keyframes appear { from { transform:scale(0); opacity:0; } to { transform:scale(1); opacity:1; } }
    .disc.appear{ animation: appear .3s ease-out; }

    /* ガイド（上: A-H、左: 1-8） */
    .guides {
      pointer-events: none;
      position: absolute; inset: 0;
      font-weight: 700; color: rgba(255,255,255,.9);
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
    }
    .guide-top {
      position: absolute; left: calc(var(--gap) * 2 + 18px); right: calc(var(--gap) * 2 + 18px); top: 6px;
      display: grid; grid-template-columns: repeat(8, 1fr); font-size: clamp(10px, 2.2vw, 14px); text-align: center;
    }
    .guide-left {
      position: absolute; top: calc(var(--gap) * 2 + 18px); bottom: calc(var(--gap) * 2 + 18px); left: 6px;
      display: grid; grid-template-rows: repeat(8, 1fr); font-size: clamp(10px, 2.2vw, 14px); text-align: left;
    }

    /* コマンドボタン */
    .controls{
      display:flex; gap:8px; align-items:center; margin-top:10px; flex-wrap: wrap;
    }
    .CmdBtn{
      padding: 8px 12px; border: 0; border-radius: 10px; cursor: pointer; font-weight: 700;
      background:#ffe082; box-shadow: 0 2px 6px rgba(0,0,0,.12), inset 0 -2px 0 rgba(0,0,0,.12);
    }
    .CmdBtn:hover{ filter: brightness(1.04); }
    .CmdBtn.new{ background:#bbdefb; }

    #toast{
      position:fixed; left:50%; bottom: 18px; transform: translateX(-50%);
      background:#333; color:#fff; padding:6px 12px; border-radius: 8px;
      font-size:14px; opacity:0; transition: opacity .25s; pointer-events:none;
      box-shadow: 0 4px 12px rgba(0,0,0,.25);
    }
    #toast.show{ opacity:1; }
  </style>
</head>
<body>
<article class="wrap">
  <div class="header">
    <div class="badge" id="turnBadge">手番: -</div>
    <div class="controls">
    <button id="btnPass" class="CmdBtn" type="button" title="合法手が無いときのみ有効">PASS</button>
    <button id="btnNew"  class="CmdBtn new" type="button" title="新しい対局を開始">NEW</button>
  </div>

    <div class="counts">
      <span class="disc b"></span><strong id="countB">0</strong>
      <span style="color:#999">:</span>
      <span class="disc w"></span><strong id="countW">0</strong>
    </div>
  </div>

  <div class="board">
    <!-- ガイド文字（上と左） -->
    <div class="guides" aria-hidden="true">
      <div class="guide-top" id="guideTop"></div>
      <div class="guide-left" id="guideLeft"></div>
    </div>
    <div class="grid" id="grid"></div>
  </div>
</article>
</div>
<div id="toast">取れません</div>

<script id="initial-state" type="application/json">
  {{initialState}}
</script>

<script>
  const gameSession = '{{gameSession}}';
  /*** ReversiEngine（import対応） ***/
  class ReversiEngine {
    constructor(){ this.init(); }
    init(){
      this.b = Array(64).fill(".");
      // 初期配置
      this.b[27] = "W"; this.b[28] = "B";
      this.b[35] = "B"; this.b[36] = "W";
      this.to = "B";
      return this.export();
    }
    import(state){
      if (!state || typeof state.board !== "string" || state.board.length !== 64) {
        throw new Error("board は64文字の文字列である必要があります");
      }
      if (state.to !== "B" && state.to !== "W") {
        throw new Error("to は 'B' または 'W'");
      }
      const arr = [];
      for (let i=0;i<64;i++){
        const ch = state.board[i];
        if (ch !== "." && ch !== "B" && ch !== "W") throw new Error("board に不正な文字があります");
        arr.push(ch);
      }
      this.b = arr;
      this.to = state.to;
      return this.export();
    }
    export(){
      const {black,white} = this.counts();
      return { board: this.b.join(""), to: this.to, legal: this.legalMoves(this.to), black, white };
    }
    opp(c){ return c==="B" ? "W" : "B"; }
    idx(coord){ return (coord.charCodeAt(1)-49)*8 + (coord.charCodeAt(0)-65); }
    rc(i){ return [Math.floor(i/8), i%8]; }
    coord(i){ return String.fromCharCode(65+(i%8)) + String.fromCharCode(49+Math.floor(i/8)); }
    counts(){
      let b=0,w=0; for(const x of this.b){ if(x==="B") b++; else if (x==="W") w++; } return {black:b,white:w};
    }
    legalMoves(color){
      const res=[]; for(let i=0;i<64;i++){ if(this.b[i]!==".") continue;
        if(this.flips(i,color).length>0) res.push(this.coord(i));
      } return res;
    }
    flips(i,color){
      if(this.b[i]!==".") return [];
      const [r,c]=this.rc(i), opp=this.opp(color);
      const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
      const res=[];
      for(const [dr,dc] of dirs){
        let rr=r+dr, cc=c+dc; const tmp=[];
        while(rr>=0&&rr<8&&cc>=0&&cc<8 && this.b[rr*8+cc]===opp){ tmp.push(rr*8+cc); rr+=dr; cc+=dc; }
        if(rr>=0&&rr<8&&cc>=0&&cc<8 && this.b[rr*8+cc]===color && tmp.length) res.push(...tmp);
      }
      return res;
    }
    playBlack(move) {
      return this.play("B", move);
    }
    play(to,coord){
      if (coord === "NEW"){
        this.init(); // 盤面初期化 手番は黒
        return { ok:true, reset:true };
      }
      if (to !== this.to) {
        return { ok: false, error: "Invalid turn" }
      }
      if (coord==="PASS"){
        const leg=this.legalMoves(this.to);
        if(leg.length) return {ok:false, error:"There are still legal options."};
        this.to=this.opp(this.to); return {ok:true, pass:true};
      }
      if (!/^[A-H][1-8]$/.test(coord)) return {ok:false, error:"Invalid coordinates."};
      const i=this.idx(coord);
      if (this.b[i]!==".") return {ok:false, error:"There is already a stone."};
      const flips=this.flips(i,this.to);
      if (!flips.length) return {ok:false, error:"Can't flip stones."};
      this.b[i]=this.to; for (const j of flips) this.b[j]=this.to;
      this.to=this.opp(this.to);
      if (this.legalMoves(this.to).length===0) this.to=this.opp(this.to); // 相手に手が無ければ自動パス
      return {ok:true, placedIdx:i, flips};
    }
  }

  /*** 初期状態の取得（script[type="application/json"] or window.INITIAL_STATE or 初期盤） ***/
  function loadInitialState(){
    const tag=document.getElementById("initial-state");
    if (tag && tag.textContent?.trim()){
      try { return JSON.parse(tag.textContent); } catch(e){ console.warn("initial-state JSON 解析失敗:", e); }
    }
    if (window.INITIAL_STATE) return window.INITIAL_STATE;
    return null;
  }

  /*** UI ***/
  const engine = new ReversiEngine();
  let state;
  try {
    const ext = loadInitialState();
    state = ext ? engine.import({ board: ext.board, to: ext.to }) : engine.init();
  } catch(e) {
    console.error("Import error:", e);
    state = engine.init();
  }

  function renderGuides(){
    // 上: A〜H
    const top = document.getElementById("guideTop");
    top.innerHTML = Array.from({length:8}, (_,i)=>String.fromCharCode(65+i))
      .map(ch=>`<div>${ch}</div>`).join("");
    // 左: 1〜8
    const left = document.getElementById("guideLeft");
    left.innerHTML = Array.from({length:8}, (_,i)=>`<div>${i+1}</div>`).join("");
  }

  function render(animCoord){
    const grid = document.getElementById("grid");
    const legal = new Set(state.legal);
    grid.innerHTML = Array.from(state.board).map((ch,i)=>{
      const coord = String.fromCharCode(65+(i%8)) + String.fromCharCode(49+Math.floor(i/8));
      const anim = (animCoord===coord) ? " appear" : "";
      return `<div class="cell" data-coord="${coord}" tabindex="0" aria-label="${coord}">
      ${ch==="B" ? `<div class="disc B${anim}"></div>` :
        ch==="W" ? `<div class="disc W${anim}"></div>` :
          legal.has(coord) ? `<div class="hint"></div>` : ``}
    </div>`;
    }).join("");

    document.getElementById("turnBadge").textContent = "Turn: " + (state.to==="B" ? "黒(B)" : "白(W)");
    document.getElementById("countB").textContent = String(state.black);
    document.getElementById("countW").textContent = String(state.white);

    grid.querySelectorAll(".cell").forEach(el=>{
      el.addEventListener("click", ()=>onCell(el.getAttribute("data-coord")));
      el.addEventListener("keydown", (ev)=>{
        if (ev.key==="Enter" || ev.key===" ") { ev.preventDefault(); onCell(el.getAttribute("data-coord")); }
      });
    });
  }

  document.getElementById("btnPass").onclick = ()=> onCell("PASS");
  document.getElementById("btnNew").onclick  = ()=> onCell("NEW");

  function showToast(msg){
    const t=document.getElementById("toast");
    t.textContent = msg || "Can't do it";
    t.classList.add("show");
    setTimeout(()=>t.classList.remove("show"), 1200);
  }
  window.reversiOnClick = function (coord,res,exp) { /* 外部連携したい場合に差し替え可 */
    console.log('Clicked:', coord,res);
    //  TODO 暗号化してサーバーに通知が望ましいが、ここではtoolの自己呼び出しにしてみる
    if(!res.ok) {
      window.parent.postMessage(
        {
          type: 'notify',
          payload: {
            message: (cood === "PASS" ? 'User made an incorrect choice. Attempting to pass despite having a legal move': 'User made an incorrect choice. User tried to place ' + to + ' on ' + coord )+'. error message is "'+res.error+'"',
          }
        }, '*');
      return
    }
    window.parent.postMessage(
      {
        type: 'tool',
        payload: {
          toolName: "select-user",
          params: {
            move: coord,  //  TODO パスやスキップも返す必要がある
          },
        },
      }, '*');
    //  連続で通知は送れないようだ toolの呼び出しの後から呼び出させる。。→AIの指摘では連続で送れるらしい。。→返すレスポンスはMCP側から返さないとシーケンスが合わない。。
    // window.parent.postMessage(
    //   {
    //     type: 'notify',
    //     payload: {
    //       message: `The user has already placed the next stone, so the board state has changed. Next, Please devise a position for the next white stone and put a white stone by put-white-stone(e.g., {"move":"A1"}). The current board state is "${JSON.stringify(exp)}".`
    //       // message: 'Board updated. User put B at ' + coord,
    //     }
    //   }, '*');
    // setTimeout(()=>{
    // }, 1200);
  };

  /*** 外向けフック：window.reversiOnClick(coord) があれば先に呼ぶ ***/
  function onCell(coord){

    const res = engine.playBlack(coord);
    if (!res.ok) {
      showToast(res.error);
      return;
    }
    const exp = engine.export();
    const fn = window.reversiOnClick;
    if (typeof fn === "function") { try { fn(coord,res,exp); } catch(e){ console.error(e); } }

    state = engine.export();
    render(coord); // 置いた石に出現アニメ
  }

  /*** 初期描画 ***/
  renderGuides();
  render();
</script>
{{postMessageUISizeChange}}
</body>
</html>
